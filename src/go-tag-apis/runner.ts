import { join } from 'path';

import { Runner, RunnerWithSchema, formateWrite, readGlobJoin } from '../common';
import { GoTagApisConfig } from '../schemas';

// key, value, comment?
const apiRe = /^(\w+)\s+string\s+`\s*default\:"([^"]+)"\s*`(?:\s*(\/\/.*))?/;
const commentRe = /\/\/(.*)/;

export class GoTagApis {

  static forLoader(): RunnerWithSchema {
    return {
      $tool: 'go-tag-apis',
      schema: require('../schemas/go-tag-apis.json'),
      runner: GoTagApis,
    };
  }

  constructor(public config: GoTagApisConfig) { }

  run(): Promise<any> {
    return readGlobJoin(this.config.src).then(sources => {
      return Promise.all(this.config.structs.map(async struct => await this.runOneStruct(sources, struct)));
    });
  }

  private runOneStruct(sources: string, struct: string): Promise<any> {
    const structRe = new RegExp(`type ${struct} struct \{([^\}]+)\}`);
    const structMatch = sources.match(structRe);
    if (!structMatch) {
      return Promise.reject(`api struct ${struct} not found.`);
    } else {
      const lines = structMatch[1].split('\n').map(line => {
        line = line.trim();
        const match = line.match(apiRe);
        if (match) {
          const p: string[] = [];
          // replace params
          let u = match[2].replace(/\/\:(\w+)/g, (m: string) => {
            m = m.slice(2);
            p.push(`${m}: any`);
            return `/\${${m}}`;
          });
          u = '`${apiOrigin}' + u + '${ext}`';
          if (p.length) {
            u = `(${p.join()}) => ${u}`;
          }
          const comment = match[3] ? `  ${match[3]}` : '';
          return `${match[1]}: ${u},${comment}`;
        } else {
          return line.match(commentRe) ? line : '';
        }
      });

      const content = `// Generated by node-private-tools
export function apis(apiOrigin: string, ext?: string) {
  ext = ext || '';
  return {
    ${lines.join('\n')}
  };
}
`;
      return formateWrite(join(this.config.dist, `${struct}.ts`), content);
    }
  }
}
